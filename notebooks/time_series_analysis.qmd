---
title: "Forecasting: Principles and practice"
subtitle: "Chapters 2-3: Time series graphics and decomposition"
format: 
    pdf:
        number-sections: true 
        toc: true
execute: 
  echo: true
  output: false
engine: knitr
---


```{r initiate-reticulate}
library('easypackages')
packages = c('reticulate', 'fpp3', 'tidyverse', 'fable', 'slider', 'seasonal')
libraries(packages)
# install.packages('seasonal')
use_condaenv("base", required = TRUE)
```

```{python loading-packages}
import os
import tarfile
import urllib
import pandas as pd
import numpy as np
from plotnine import * 

os.chdir('notebooks/')
```

```{python load-data-pyt}
df_gas = pd.read_csv('../data/raw/fueltypesall.csv')

# convert date to datetime object 
df_gas['Date'] = pd.to_datetime(df_gas['Date'])
```


```{r load-data-r}
df_gasr = read_csv('data/raw/fueltypesall.csv')

# convert date to tsibble and then to long format
df_gasr <- df_gasr |>
  pivot_longer(cols = -c(Date, `Fuel Type`, `Type de carburant`), 
               names_to = "city", values_to = "price") |> 
  mutate(week= yearweek(Date)) |>
  as_tsibble(index = week, key = c('city', `Fuel Type`))
```


## Time plots

```{r time-plots}
# plot gas prices in toronto over time
toronto = df_gasr |>
  filter(city == 'Toronto East/Est')

plot_toronto = autoplot(toronto) + 
  labs(y='price') + 
  theme_classic()

ggsave("figures/toronto_plot.png", plot = plot_toronto, width = 8, height = 6)
```

```{python time-plots-py}
# Create the same plot using Python 
plot_toronto = (
    ggplot(df_gas, aes(x='Date', y='Toronto East/Est', color ="Fuel Type")) +
    geom_line() +
    labs(y='price') +
    theme_classic()
)
```

 
## Time series patterns 

1. **Trend**: a long-term change that does not have to be linear. 
2. **Seasonal**: changes that occur for fixed and known periods (e.g., holidays, seasons)
3. **Cyclic**: rises and falls that are not of a fixed frequency (e.g., economic conditions) and last at least 2 years. 

Plots below examine quarterly data. 

```{r r-quarterly}
aus_production |> 
  filter(year(Quarter) >= 1980) |>
  autoplot(Electricity) +
  labs(y='gWh', title='Australian electricity production') + 
  theme_classic()
```
![toronto plot](figures/toronto_plot.png){width=400px height=300px}

```{python python-quarterly}
(ggplot(r.aus_production, aes(x='Quarter', y='Electricity')) +
    geom_line() +
    labs(y='price') +
    theme_classic()
)
```


# Time series decomposition


Adjustments are often useful as they create simpler time series. There are four common types of adjustments: 

1) Calendar: Instead of computing average sales per month, reduce it down to sales/day, as the number of selling days differ by month. 
2) Population: Similarly, compute population variables at to either per capita or relative to some fixed denominator (1000)
3) Inflation: adjust financial data such that they are expressed in common dollars (i.e., adjusted for infation). 
4) Mathematical: if data are heteroscedastic, log transformations are useful (and also still interpretable). 

## Time series components

There are two types of decompositions: 

1. **Additive**. Value at any given $y_t$ time point is the sum of a seasonal ($S_t$), trend-cycle ($T_t$), and remainder ($R_t$) component. 

$$
y_t = S_t + T_t + R_t
$$

2. **Mulitplicative**. Value at any given $y_t$ time point is the product of a seasonal ($S_t$), trend-cycle ($T_t$), and remainder ($R_t$) component. 

$$
y_t = S_t \times T_t \times  R_t
$$

Additive decompoisiton is appropriate if neither $S_t$ or $T_t$ vary with the level of $y_t$. If not, multiplicative decomposition is more appropriate. Alternative, if there is heteroscedasity in either the seasonal or trend-cycle components, then transformations can be applied to instill stability in the data. On this point, note that using a log transformation is equivalent to using the multiplicative decomposition. 

### Examle: Employment in the US retail sector

```{r retail-plot}
us_retail_employment = us_employment |>
  filter(year(Month) >= 1990, Title == "Retail Trade") |>
  select(-Series_ID)

autoplot(us_retail_employment, Employed) +
  labs(y = "Persons (thousands)",
       title = "Total employment in US retail")
```


Code applies STL decomposition. NOtice that the `season_adjust` column represents the observed score without the seasonality component (i.e., `y_t - S_t`), but without the remainder. To better interpret changes, look only at the trend pattern. 

```{r stl-decomp}
dcmp <- us_retail_employment |>
  model(stl = STL(Employed))

stl_output = components(dcmp)

components(dcmp) |>
  as_tsibble() |>
  autoplot(Employed, colour="gray") +
  geom_line(aes(y=trend), colour = "#D55E00") +
  labs(
    y = "Persons (thousands)",
    title = "Total employment in US retail"
  )


# plots all three components 
# components(dcmp) |> autoplot()
```


## Moving averages

Moving average smoothing computes a moving average, $\hat{T}_t$ by taking the *k* observations that precede and follow the current *t* observation (note that $m = 2k+1$)

$$ 
\hat{T}_t = \frac{1}{m} \sum^k_{j=-k} y_{t+j}
$$

In R, the `slide_dbl()` function can be used to compute moving averages. 

```{r moving-average}
aus_exports <- global_economy |>
  filter(Country == "Australia") |>
  mutate(
    `5-MA` = slider::slide_dbl(Exports, mean,
                .before = 2, .after = 2, .complete = TRUE)
  )

aus_exports |>
  autoplot(Exports) +
  geom_line(aes(y = `5-MA`), colour = "#D55E00") +
  labs(y = "% of GDP",
       title = "Total Australian exports")
```

To obtain a centered series of moving averages, a moving can be taken of a moving average. This is commonly done with seasonal data. A more refined method is to use weighted moving averages where 

$$
\hat{T}_t = \sum^k_{j=-k} a_j y_{t+j}
$$

Weighted moving averages result in smoother trend cycles.

## Classical decomposition 

This is a simple decomposition and acts as a starting point for understanding time series analyses. As with STL decomposition, additive and multiplicative versions exist. The difference here is that the seasonal component, $S_t$, is assumed to be constant over time. 

### Additive decomposition

1. Use $2 /times m-MA$ is time series has even number of observations. 
2. Compute detrended time series, $y_t - \hat{T}_t$
3. Estimate the seasonal component, $\hat{S}_t$, by computing the mean value across all seasonal components across all years. For example, take the average of all $y_t - \hat{T}_t$ in February across all years. Importantly, the seasonal component values are then adjusted such that they sum to zero. Thinking here is that if the seasonal components do not sum to zero, then the excess will carry into the trend/noise. This is solved by mean centering. 
4. Compute remainder, $\hat{R}_t = y_t - \hat{T}_t - \hat{S}_t$. 

```{r classical-decom}
us_retail_employment |>
  model(
    classical_decomposition(Employed, type = "additive")) |>
  components() |>
  autoplot() +
  labs(title = "Classical additive decomposition of total
                  US retail employment")
```

### Multiplicative decomposition

1. Use $2 /times m-MA$ is time series has even number of observations. 
2. Compute detrended time series, $\frac{y_t}{\hat{T}_t}$
3. Estimate the seasonal component, $\hat{S}_t$, by computing the mean value across all seasonal components across all years. For example, take the average of all $y_t - \hat{T}_t$ in February across all years. Importantly, the seasonal component values are then adjusted such that they sum to zero. Thinking here is that if the seasonal components do not sum to zero, then the excess will carry into the trend/noise. This is solved by mean centering. 
4. Compute remainder, $\hat{R}_t = \frac{y_t}{\hat{T}_t \hat{S}_t}$. 

Classical decomposition has several limitations: 

1. No estimate of first and last $m$ time periods for $\hat{T}$ or $\hat{R}$. 
2. Trend cycle, $\hat{T}$, gives overly smooth estimates that miss out on sudden changes. 
3. Assumption of constant $\hat{S}_t$ is tenuous. 
4. Cannot handle unusual incidences (e.g., worker strike causing)


## Methods used by official statistics agencies

Over time, several agencies have developed methods to deal with seasonal adjustments. These methods are largely variants of the X-11 and SEATS methods. Importantly, these methods are designed to deal with quarterly and monthly data and so cannot handle any other types of data (daily, weekly, hourly, etc.). 

### X-11 method

Improved classical decomposition to handle 

1. Missingness of trend values at first and last m values. 
2. Allows seasonal component to change over time. 
3. Can incorporate trading day variation, holidays, and effects of known preditros. 


```{r x11-vs-class}
plot_class = us_retail_employment |>
  model(
    classical_decomposition(Employed, type = "additive")
  ) |>
  components() |>
  autoplot() +
  labs(title = "Classical additive decomposition of total
                  US retail employment")

ggsave("notebooks/figures/class_add_employment.png", plot = plot_class, width = 8, height = 6)


x11_dcmp <- us_retail_employment |>
  model(x11 = X_13ARIMA_SEATS(Employed ~ x11(mode='add'))) |>
  components()

plot_x11 = autoplot(x11_dcmp) +
  labs(title =
    "Decomposition of total US retail employment using X-11.")

ggsave("notebooks/figures/x11_add_employment.png", plot = plot_x11, width = 8, height = 6)
```

![Classical decomposition](figures/x11_add_employment.png){width=400px height=300px}
![X-11 method](figures/class_add_employment.png){width=400px height=300px}


THe X11 method has estimated trend values values at the beginning and end of the time period, has better overall resolution in the trend cycle, and captures the oddity in 1996 (within the remainder term). 

The seasonal values can also be examined across months across year year. 

```{r seasonal}
plot_seasonal = x11_dcmp |>
  gg_subseries(seasonal)

ggsave("notebooks/figures/x11_add_seasonal_plot.png", plot = plot_seasonal, width = 8, height = 6)
```

![Seasonal plot](figures/x11_add_seasonal_plot.png){width=400px height=300px}


### SEATS method

The Seasonal Extraction in ARIMA Time Series (SEATS) method  has the same three components as the X-11 method, but fits an ARIMA model to the data.  

```{r seats}

seats_dcmp <- us_retail_employment |>
  model(seats = X_13ARIMA_SEATS(Employed ~ seats())) |>
  components()
autoplot(seats_dcmp) +
  labs(title =
    "Decomposition of total US retail employment using SEATS")
```

## STL decomposition

Several advantages over SEATS and X-11 methods: 

1. Can handle any type of frequnecy of data. 
2. Seasonal component can change over time. 
3. Smoothness of trend-cylcle. 
4. Robust decomposition can be specified to instill robustness against outliers. Note this will affect the remainder component. 

Some disadvantages: 

1. Does not automatically handle trading day variation or calendar variation. 
2. Only has additive decomposition. That being said, logs of data can be computed to obtain a multiplicative decomoposition. Also, decompositions that lie between additive and multiplicative decompositions can be obtained by using Box-Cox transformation with $0 < \lambda < 1$. 